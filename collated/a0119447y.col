//@author: a0119447y



	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\infrastructure\NerParser.java
	 */

	public ArrayList<String> pickUntag(String userInputString) throws CommandFailedException {
		String tagString = UtilityMethod.removeFirstWord(UtilityMethod.removeFirstWord(userInputString));
		ArrayList<String> results = new ArrayList<String>();
		try {
			String[] tags = tagString.split(Constant.SPLITOR_SPACE);
			for (String thisTag : tags) {
				if (!results.contains(thisTag)) {
					results.add(thisTag);
				}
			}
		} catch (Exception e1) {
			if (results.size() != Constant.LIST_SIZE_EMPTY) {
				return results;
			} 
			
			try {
				String[] tags = tagString.split(Constant.SPLITOR_COMMA);
				for (String thisTag : tags) {
					results.add(thisTag);
				}
			} catch (Exception e2) {
				if (results.size() != Constant.LIST_SIZE_EMPTY) {
					return results;
				}
				throw new CommandFailedException(Constant.EXCEPTION_MESSAGE_INDEX_NOT_PARSABLE);
			}
		}
		return results;
	}
	

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\infrastructure\NerParser.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\CommandFailedException.java
	 */

	//Parameterless Constructor
    public CommandFailedException() {
    	super();
    }

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\CommandFailedException.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\CommandFailedException.java
	 */

    //Constructor that accepts a message
    public CommandFailedException(String message)
    {
       super(message);
       UtilityMethod.logger.log(Level.INFO, message);
    }

}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\CommandFailedException.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Constraint.java
	 */

	public Constraint(String[] keyword, Date startDate, Date endDate)
			throws Exception {
		this.keywords = keyword;
		this.interval = new TimeInterval(startDate, endDate);
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Constraint.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Constraint.java
	 */

	public Constraint(String[] keyword, TimeInterval timeInterval) {
		this.keywords = keyword;
		this.interval = timeInterval;
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Constraint.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Constraint.java
	 */

	public Constraint() {
		this.keywords = null;
		this.interval = new TimeInterval();
	}

	/**
	 * isMeeted checks whether a task can meet the given constraint.	
	 * 
	 * @param task
	 * @return boolean
	 * @throws Exception
	 */
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Constraint.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java
	 */

	private String description;
	private int priority;
	private ArrayList<String> tag;
	private TimeInterval interval;
	private String status;
	private final int REDUCE_CHAR = 1;
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java
	 */

	/**
	 * constructor 
	 * 
	 * @param description	description task description
	 * @param priority		priority task priority
	 * @param tag			tag task tags list
	 * @param interval		interval task time interval
	 */
	public Task(String description, int priority, ArrayList<String> tag, TimeInterval interval) {
		this.description = description;
		this.priority = priority;
		this.tag = tag;
		this.interval = interval;
		this.status = Constant.TASK_STATUS_ONGOING;
	}

	
	/**
	 * ==================================================================================================
	 * ======================================== API methods =============================================
	 * ==================================================================================================
	 */
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java
	 */

	/**
	 * Insert a tag for this task, user cannot add duplicated tag for a task
	 * 
	 * @param tag	tag the tag to be added
	 * @return 		whether the tag has been added successfully
	 * @throws CommandFailedException
	 */
	public boolean addTag(String tag) throws CommandFailedException {
		if (this.tag.contains(tag)) {
			throw new CommandFailedException(String.format(
					Constant.DUPLICATED_TAG_ERROR_MESSAGE, tag));
		} else {
			return this.tag.add(tag);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java
	 */

	/**
	 * Remove a tag for this task
	 * 
	 * @param tag	tag to be removed
	 * @return 		whether the tag has been removed successfully
	 */
	public boolean removeTag(String tag) {
		return this.tag.remove(tag);
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java
	 */

	/**
	 * Convert the task information to a string for displaying
	 * 
	 * @return 	String for displaying
	 */
	public String toStringForDisplaying() {
		String task = "description:\t";

		task = task + getDescription();
		if (!this.tag.isEmpty()) {
			task = task + "\ntags: \t\t" + tagToString();
		}
	
		task = task + "\npriority: \t" + UtilityMethod.priorityToString(getPriority());
		task = task + this.getInterval().toString();

		return task;
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java
	 */

	/**
	 * Check whether a task is trashed
	 *
	 * @return 	whether a task is trashed
	 */
	public boolean isTrashed() {
		if (this.status.equals(Constant.TASK_STATUS_TRASHED)) {
			return true;
		} else {
			return false;
		}
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java
	 */

	/**
	 * Check whether a task is ongoing
	 *
	 * @return 	whether a task is ongoing
	 */
	public boolean isOngoing() {
		if (this.status.equals(Constant.TASK_STATUS_ONGOING)) {
			return true;
		} else {
			return false;
		}
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java
	 */

	/**
	 * Check whether a task is done
	 *
	 * @return 	whether a task is done
	 */
	public boolean isDone() {
		if (this.status.equals(Constant.TASK_STATUS_DONE)) {
			return true;
		} else {
			return false;
		}
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java
	 */

	/**
	 * Check whether the task is floating task, i.e. there is no start date or end date for it
	 * 
	 * @return 	whether the task is floating task
	 */
	public boolean isFloating() {
		if (this.getInterval().getStartDate().equals(Constant.FLOATING_START_DATE)) {
			return true;
		} else {
			return false;
		}
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java
	 */

	/**
	 * Check whether the task is deadline task, i.e. there is only a deadline for it
	 * 
	 * @return 	whether the task is deadline task
	 */
	public boolean isDeadline() {
		if (this.getInterval().getStartDate().equals(Constant.DEADLINE_START_DATE)) {
			return true;
		} else {
			return false;
		}
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java
	 */

	/**
	 * Check whether the task is timed task
	 * 
	 * @return 	whether the task is timed task
	 */
	public boolean isTimed() {
		if (!this.isDeadline() && !this.isFloating()) {
			return true;
		} else {
			return false;
		}
	}

	
	/**
	 * ==================================================================================================
	 * ========================================= Unused methods =========================================
	 * ==================================================================================================
	 */
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\Task.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TaskBox.java
	 */

/**
 * TaskBox class is used to contain the three different task lists for user, namely,
 * ongoing tasks list, finished tasks list, and trashed tasks list.
 *
 */
public class TaskBox {
	private ArrayList<Task> ongoingTasks;
	private ArrayList<Task> finishedTasks;
	private ArrayList<Task> trashedTasks;
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TaskBox.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TaskBox.java
	 */

	/**
	 * Constructor for task box class
	 */
	public TaskBox() {
		this.ongoingTasks = new ArrayList<Task>();
		this.finishedTasks = new ArrayList<Task>();
		this.trashedTasks = new ArrayList<Task>();
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TaskBox.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TaskBox.java
	 */

	/**
	 * Retrieve the ongoing task from the task box
	 * 
	 * @return array list of all the ongoing tasks
	 */
	public ArrayList<Task> getOngoingTasks() {
		return ongoingTasks;
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TaskBox.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TaskBox.java
	 */

	/**
	 * Retrieve the finished task from the task box
	 * 
	 * @return array list of all the finshed tasks
	 */
	public ArrayList<Task> getFinishedTasks() {
		return finishedTasks;
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TaskBox.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TaskBox.java
	 */

	/**
	 * Retrieve the trashed task from the task box
	 * 
	 * @return array list of all the trashed tasks
	 */
	public ArrayList<Task> getTrashedTasks() {
		return trashedTasks;
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TaskBox.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java
	 */

	/**
	 * Constructor for TimeInterval class
	 * @param startDate
	 * @param endDate
	 * @throws Exception
	 */
	public TimeInterval(Date startDate, Date endDate) throws CommandFailedException {
		if (startDate == null) {
			if (endDate != null) {
				startDate = Constant.DEADLINE_START_DATE;
			} else {
				startDate = Constant.FLOATING_START_DATE;
			}
		}
		
		if (endDate == null) {
			endDate = Constant.FLOATING_END_DATE;
		}
		
		if (!isValid(startDate, endDate)) {
			throw new CommandFailedException("invalid time interval");
		} else {
			this.startDate = startDate;
			this.endDate = endDate;
		}
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java
	 */

	/**
	 * Constructor for empty TimeInterval
	 */
	public TimeInterval() {
		// by default it is floating task
		this.startDate = Constant.FLOATING_START_DATE;
		this.endDate = Constant.FLOATING_END_DATE;
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java
	 */

	/**
	 * Retrieve the start date
	 * 
	 * @return 	the start date of this time interval
	 */
	public Date getStartDate() {
		return this.startDate;
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java
	 */

	/**
	 * Retrieve the end date
	 * 
	 * @return 	the end date of this time interval
	 */
	public Date getEndDate() {
		return this.endDate;
	}
	
	/**
	 * check whether a time interval is valid
	 * @param startDate
	 * @param endDate
	 * @return boolean
	 */
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java
	 */

	/**
	 * Check whether two time interval are overlapped
	 * 
	 * @param firstInterval
	 * @param secondInterval
	 * @return	whether two time interval are overlapped
	 */
	public static boolean isOverlapped(TimeInterval firstInterval, TimeInterval secondInterval) {
		if ((firstInterval.getStartDate().after(secondInterval.getEndDate())) || 
		   (firstInterval.getEndDate().before(secondInterval.getStartDate()))) {
			return false;
		} else {
			return true;
		}
	}
	
	/**
	 * check is overlapped for an interval and a deadline
	 * @param interval
	 * @param deadline
	 * @return
	 */
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java
	 */

	/**
	 * Two time intervals are equal if and only if their start date and end date are both equal
	 * @param t
	 * @return
	 */
	public boolean equals(TimeInterval t) {
		return (this.getStartDate().compareTo(t.getStartDate()) == 0) &&
				(this.getEndDate().compareTo(t.getEndDate()) == 0);
	}
}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\TimeInterval.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	public TaskBox currentTasks;
	private Stack<TaskBox> undoable;
	private Stack<TaskBox> redoable;
	private Cloner cloner = new Cloner();

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Constructor for class User
	 * 
	 * @throws Exception
	 */
	public User() throws Exception {
		currentTasks = DataStore.loadFileData();
		undoable = new Stack<TaskBox>();
		redoable = new Stack<TaskBox>();
	}

	/**
	 * ========================================================================
	 * ============ Functionality methods: CRUD, undo, redo, search ===========
	 * ========================================================================
	 */

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Reset the current task list to one step backwards.
	 * 
	 * @return whether the task has been undone successfully
	 * @throws CommandFailedException
	 */
	public void undo() throws CommandFailedException {
		if (this.undoable.empty()) {
			// no archived task list in the history
			throw new CommandFailedException(Constant.NO_UNDOABLE_ERROR_MESSAGE);
		} else {
			this.redoable.push(cloner.deepClone(this.currentTasks));

			if (this.redoable.size() > Constant.MAXIMUM_REDO_TIMES) {
				this.redoable.remove(0);
			}

			// reload current task list 
			this.currentTasks = cloner.deepClone(this.undoable.pop());
			DataStore.save(this.currentTasks);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Reset the current task list to one step forwards.
	 * 
	 * @return whether the task has been redone successfully
	 * @throws CommandFailedException
	 */
	public void redo() throws CommandFailedException {
		if (this.redoable.empty()) {
			// no archived task list in the history
			throw new CommandFailedException(Constant.NO_REDOABLE_ERROR_MESSAGE);
		} else {
			this.undoable.push(cloner.deepClone(this.currentTasks));

			if (this.undoable.size() > Constant.MAXIMUM_UNDO_TIMES) {
				this.undoable.remove(0);
			}

			// reload current task list 
			this.currentTasks = cloner.deepClone(this.redoable.pop());

			DataStore.save(this.currentTasks);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Add a task into the current task list.
	 * 
	 * @param task 	task the task to be added
	 * @return		whether the task has been added successfully
	 */
	public boolean add(Task task) {
		this.updateUndoable();
		this.currentTasks.getOngoingTasks().add(task);
		boolean isSuccessful = DataStore.save(this.currentTasks);
		return isSuccessful;
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Delete given index from the specified list name 
	 * 
	 * @param index		index of the task in the corresponding list
	 * @param listName	listName where the task is delete from
	 * @return			whether the task has been deleted successfully
	 * @throws CommandFailedException
	 */
	public boolean delete(int index, String listName)
			throws CommandFailedException {
		switch (listName) {
		case Constant.TASK_LIST_ONGOING:
			return this.deleteOngoing(index, true);

		case Constant.TASK_LIST_FINISHED:
			return this.deleteFinished(index, true);

		default:
			throw new CommandFailedException(
					Constant.PROMPT_MESSAGE_INVALID_TASK_LISE);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Deletes all tasks from the corresponding list
	 * 
	 * @param listName	listName where the task is delete from
	 * @return			whether the tasks have been deleted successfully
	 * @throws CommandFailedException
	 */
	public boolean deleteAll(String listName) throws CommandFailedException {
		switch (listName) {
		case Constant.TASK_LIST_ONGOING:
			return this.deleteAllOngoing();

		case Constant.TASK_LIST_FINISHED:
			return this.deleteAllFinished();

		default:
			throw new CommandFailedException(
					Constant.PROMPT_MESSAGE_INVALID_TASK_LISE);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Put the trashed tasks back to ongoing task list
	 * 
	 * @param trashedIndex	index of task in trashed list
	 * @return				whether the tasks have been deleted successfully
	 * @throws CommandFailedException
	 */
	public boolean putBack(int trashedIndex) throws CommandFailedException {
		if (!this.isValidTrashedIndex(trashedIndex)) {
			throw new CommandFailedException(String.format(
					Constant.INVALID_INDEX_ERROR_MESSAGE, trashedIndex));
		} else {
			this.updateUndoable();
			// the task list to be put back
			Task putBackTask = cloner.deepClone(this.currentTasks
					.getTrashedTasks().remove(trashedIndex));
			putBackTask.setStatus(Constant.TASK_STATUS_ONGOING);
			this.currentTasks.getOngoingTasks().add(putBackTask);
			
			return DataStore.save(this.currentTasks);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Mark a ongoing task as done
	 * 
	 * @param normalIndex	the index in the ongoing task list
	 * @return				whether the tasks have been marked as done successfully
	 * @throws CommandFailedException
	 */
	public boolean done(int normalIndex) throws CommandFailedException {
		if (!this.isValidOngoingIndex(normalIndex)) {
			throw new CommandFailedException(String.format(
					Constant.INVALID_INDEX_ERROR_MESSAGE, normalIndex));
		} else {
			this.updateUndoable();
			Task doneTask = cloner.deepClone(this.currentTasks.getOngoingTasks()
					.remove(normalIndex));
			doneTask.setStatus(Constant.TASK_STATUS_DONE);
			this.currentTasks.getFinishedTasks().add(doneTask);
			return DataStore.save(this.currentTasks);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Mark a finished task as ongoing
	 * 
	 * @param finishedIndex		the index in the finished task list
	 * @return					whether the tasks have been marked as ongoing successfully
	 * @throws CommandFailedException
	 */
	public boolean unDone(int finishedIndex) throws CommandFailedException {
		if (!this.isValidFinishedIndex(finishedIndex)) {
			throw new CommandFailedException(String.format(
					Constant.INVALID_INDEX_ERROR_MESSAGE, finishedIndex));
		} else {
			this.updateUndoable();
			Task doneTask = cloner.deepClone(this.currentTasks.getFinishedTasks()
					.remove(finishedIndex));
			doneTask.setStatus(Constant.TASK_STATUS_ONGOING);
			this.currentTasks.getOngoingTasks().add(doneTask);
			return DataStore.save(this.currentTasks);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Clear all the trashed task list
	 * 
	 * @return 	whether the trashed tasks have been cleared successfully
	 */
	public boolean emptyTrash() {
		this.updateUndoable();
		this.currentTasks.getTrashedTasks().clear();
		return DataStore.save(this.currentTasks);
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Retrieve the list of tasks that meet the constraint.
	 * 
	 * @param constraint	constraint the constraint to be searched
	 * @param listName		listName the list where the tasks are to be searched
	 * @return				array list of results that match the constraint
	 * @throws Exception
	 */
	public ArrayList<Task> find(Constraint constraint, String listName)
			throws Exception {
		switch (listName) {
		case Constant.TASK_LIST_ONGOING:
			return this.findOngoing(constraint);

		case Constant.TASK_LIST_FINISHED:
			return this.findFinished(constraint);

		case Constant.TASK_LIST_TRASHED:
			return this.findTrashed(constraint);

		default:
			throw new CommandFailedException(String.format(Constant.PROMPT_MESSAGE_NO_TASK_FOUND_IN_LIST, listName));
		}
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Remove the tag from the task with ongoingIndex
	 * 
	 * @param ongoingIndex
	 * @return 	whether the tag is removed successfully
	 * @throws 	CommandFailedException
	 */
	public boolean untag(int ongoingIndex, String tag) throws CommandFailedException {
		if (!isValidOngoingIndex(ongoingIndex)) {
			throw new CommandFailedException(String.format(
					Constant.INVALID_INDEX_ERROR_MESSAGE, ongoingIndex));
		} else {
			this.updateUndoable();
			this.getOngoingTaskList().get(ongoingIndex).removeTag(tag);
			return DataStore.save(this.currentTasks);
		}
	}

	/**
	 * ========================================================================
	 * ========================== Auxiliary methods ===========================
	 * ========================================================================
	 */

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Retrieve the ongoing task list
	 * 
	 * @return 	array list of all the ongoing tasks
	 */
	public ArrayList<Task> getOngoingTaskList() {
		return this.currentTasks.getOngoingTasks();
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Retrieve the trashed task list
	 * 
	 * @return 	array list of all the trashed tasks
	 */
	public ArrayList<Task> getTrashedTaskList() {
		return this.currentTasks.getTrashedTasks();
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Retrieve the finished task list
	 * 
	 * @return 	array list of all the finished tasks
	 */
	public ArrayList<Task> getFinishedTaskList() {
		return this.currentTasks.getFinishedTasks();
	}

	/**
	 * ========================================================================
	 * =========================== Private methods ============================
	 * ========================================================================
	 */

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Deletes the task with the index from the ongoing task list.
	 * 
	 * @param ongoingIndex		ongoingIndex index of the task to be deleted
	 * @param willUpdateUndo	willUpdateUndo whether the undoable stack will be updated
	 * @return					whether the task is deleted successfully 
	 * @throws CommandFailedException
	 */
	private boolean deleteOngoing(int ongoingIndex, boolean willUpdateUndo)
			throws CommandFailedException {
		if (!this.isValidOngoingIndex(ongoingIndex)) {
			throw new CommandFailedException(String.format(
					Constant.INVALID_INDEX_ERROR_MESSAGE, ongoingIndex));
		} else {
			if (willUpdateUndo) {
				this.updateUndoable();
			}
			Task removedTask = cloner.deepClone(this.currentTasks
					.getOngoingTasks().remove(ongoingIndex));
			removedTask.setStatus(Constant.TASK_STATUS_TRASHED);
			this.currentTasks.getTrashedTasks().add(removedTask);
			return DataStore.save(this.currentTasks);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Deletes the task with the index from the finished task list.
	 * 
	 * @param finishedIndex		finishedIndex index of the task to be deleted
	 * @param willUpdateUndo	willUpdateUndo whether the undoable stack will be updated
	 * @return					whether the task is deleted successfully 
	 * @throws CommandFailedException
	 */
	private boolean deleteFinished(int finishedIndex, boolean willUpdateUndo)
			throws CommandFailedException {
		if (!this.isValidFinishedIndex(finishedIndex)) {
			throw new CommandFailedException(String.format(
					Constant.INVALID_INDEX_ERROR_MESSAGE, finishedIndex));
		} else {
			if (willUpdateUndo) {
				this.updateUndoable();
			}
			Task removedTask = cloner.deepClone(this.currentTasks
					.getFinishedTasks().remove(finishedIndex));
			removedTask.setStatus(Constant.TASK_STATUS_TRASHED);
			this.currentTasks.getTrashedTasks().add(removedTask);
			return DataStore.save(this.currentTasks);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Delete all the ongoing tasks
	 * 
	 * @return		whether the tasks are deleted successfully
	 * @throws CommandFailedException
	 */
	public boolean deleteAllOngoing() throws CommandFailedException {
		this.updateUndoable();
		for (int i = this.currentTasks.getOngoingTasks().size() - 1; i >= 0; i--) {
			// since delete all is considered one command step, the undoable stack
			// will not be updated
			this.deleteOngoing(i, false);
		}
		return DataStore.save(this.currentTasks);
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Delete all the finished tasks
	 * 
	 * @return		whether the tasks are deleted successfully
	 * @throws CommandFailedException
	 */
	public boolean deleteAllFinished() throws CommandFailedException {
		this.updateUndoable();
		for (int i = this.currentTasks.getFinishedTasks().size() - 1; i >= 0; i--) {
			// since delete all is considered one command step, the undoable stack
			// will not be updated
			this.deleteFinished(i, false);
		}
		return DataStore.save(this.currentTasks);
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java
	 */

	/**
	 * Update the undoable stack
	 * this method should be called before every operation involving task list
	 */
	private void updateUndoable() {
		this.redoable.clear();
		this.undoable.push(cloner.deepClone(this.currentTasks));
		if (this.undoable.size() > Constant.MAXIMUM_UNDO_TIMES) {
			this.undoable.remove(0);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\model\User.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\test\TaskTest.java
	 */

	/**
	 * test for interval method in Task
	 */
	@Test
	public void testInterval() {
		try {
			TimeInterval interval = new TimeInterval(new Date(34826), new Date());
			Task task1 = new Task("task1", 0, null, interval);
			
			testInterval("task1 interval", 
						   interval, 
						   task1);
			
			System.out.println("all interval tests are passed");
		} catch (CommandFailedException e) {
			e.printStackTrace();
		}
		
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\test\TaskTest.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\test\TaskTest.java
	 */

	private void testInterval(String description, TimeInterval expected, Task task) {
		try {
			assertEquals(description, expected, task.getInterval());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\test\TaskTest.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\test\UserTest.java
	 */

	@Test
	public void testUndone() throws Exception {
		User user = new User();
		ArrayList<String> tag = new ArrayList<String>();
		TimeInterval interval = new TimeInterval();
		Task task = new Task("another test task", 2, tag, interval);
		
		ArrayList<Task> tasks = user.getOngoingTaskList();
		if (!tasks.isEmpty()){
			user.done(0);
			user.unDone(user.getFinishedTaskList().size() - 1);
			testUndone("test undone", tasks, user.getOngoingTaskList());
		} else {
			user.add(task);
			tasks = user.getOngoingTaskList();
			user.done(0);
			user.unDone(user.getFinishedTaskList().size() - 1);
			testUndone("test putBack", tasks, user.getOngoingTaskList());
		}
		System.out.println("all undone tests are passed");
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\test\UserTest.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\test\UserTest.java
	 */

	/**
	 * test method for testing unDone method
	 */	
	private void testUndone(String description, ArrayList<Task> expected, ArrayList<Task> actual) {
		try {
			assert(expected.equals(actual));
		} catch (Exception e) {
			
		}
	}
}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\test\UserTest.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java
	 */

	public static GridPane getTaskPane(ArrayList<Task> taskList, double width) {
		GridPane taskPane = new GridPane();
		int row = 1;
		int index = 1;
		taskPane.getColumnConstraints().add(new ColumnConstraints(5));
		
		GridPane placeHolderPane = LayoutManager.getEmptyPane(width - 55);
		taskPane.add(placeHolderPane, 1, 0, 2, 1);
		LayoutManager.setDisplayRow(taskPane, Constant.GRID_ROW_HEIGHT / 2);
		
		if (taskList != null) {
			for (Task task : taskList) {
				int subRow = 0;
				GridPane panePane = new GridPane();
				String bannerColor = LayoutManager.getBannerColor(task);
				GridPane priorityPane = LayoutManager.getPriorityPane(bannerColor, index, width - 55);
				panePane.add(priorityPane, 0, subRow, 2, 1);
				LayoutManager.setDisplayRow(panePane, Constant.GRID_ROW_HEIGHT);
				subRow ++;
				
				GridPane contentPane = LayoutManager.getContentPane(task, width - 55);
				
				panePane.add(contentPane, 0, subRow, 1, 2);
				LayoutManager.setDisplayRow(panePane, Constant.GRID_ROW_HEIGHT * 2 + 11);
				panePane.setStyle(Constant.CSS_STYLE_SHADOW);
				
				taskPane.add(panePane, 1, row, 2, 1);
				LayoutManager.setDisplayRow(taskPane, Constant.GRID_ROW_HEIGHT * 3 + 11);
				
				GridPane emptyPane = LayoutManager.getEmptyPane(width - 55);
				taskPane.add(emptyPane, 1, row + 1, 2, 1);
				LayoutManager.setDisplayRow(taskPane, Constant.GRID_ROW_HEIGHT);
				row += 2;
				index ++;
			}
		}
		return taskPane;
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java
	 */

	public static String getBodyColor(Task task) {
		switch (task.getPriority()) {
			case Constant.PRIORITY_HIGH:
				return Constant.COLOR_BODY_PRIORITY_HIGH;
	
			case Constant.PRIORITY_MEDIUM:
				return Constant.COLOR_BODY_PRIORITY_MEDIUM;
				
			case Constant.PRIORITY_LOW:
				return Constant.COLOR_BODY_PRIORITY_LOW;
				
			default:
				return Constant.COLOR_BODY_DEFAULT;
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java
	 */

	public static String getBannerColor(Task task) {
		switch (task.getPriority()) {
			case Constant.PRIORITY_HIGH:
				return Constant.COLOR_BANNER_PRIORITY_HIGH;
	
			case Constant.PRIORITY_MEDIUM:
				return Constant.COLOR_BANNER_PRIORITY_MEDIUM;
				
			case Constant.PRIORITY_LOW:
				return Constant.COLOR_BANNER_PRIORITY_LOW;
				
			default:
				return Constant.COLOR_BANNER_DEFAULT;
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java
	 */

	public static GridPane getPriorityPane(String bannerColor, int index, double width) {
		GridPane priorityPane = new GridPane();
		priorityPane.setAlignment(Pos.CENTER_RIGHT);
		priorityPane.setStyle(String.format(Constant.CSS_STYLE_PRIORITY_PANE, bannerColor));
		priorityPane.setPrefWidth(width);
		
		Label priorityLabel = new Label(String.format("%d", index));
		priorityLabel.setStyle(Constant.CSS_STYLE_PRIORITY_LABEL);
		priorityLabel.setPrefWidth(width);
		priorityPane.getChildren().add(priorityLabel);
		return priorityPane;
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java
	 */

	public static GridPane getContentPane(String bodyColor, double width) {
		GridPane contentPane = new GridPane();
		contentPane.setGridLinesVisible(false);
	    contentPane.getColumnConstraints().add(new ColumnConstraints(LayoutManager.calculateDescriptionWidth(width)));
		contentPane.getColumnConstraints().add(new ColumnConstraints(LayoutManager.calculateTimeWidth(width)));
		contentPane.setStyle(String.format(Constant.CSS_STYLE_CONTENT_PANE, bodyColor));
		contentPane.setPrefWidth(width);
		return contentPane;
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java
	 */

	public static void setDisplayRow(GridPane pane, double height) {
		pane.getRowConstraints().add(new RowConstraints(height));
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java
	 */

	public static Double calculateDescriptionWidth(Double fullWidth) {
		return fullWidth * 0.646 - 29;
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java
	 */

	public static Double calculateTimeWidth(Double fullWidth) {
		return fullWidth * 0.37 - 29;
	}
}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\LayoutManager.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java
	 */

	/**
	 * Constructor for MainViewController
	 * @param stage
	 */
	public MainViewController(Stage stage) {
		try {
			this.copyUserNlpFiles();
			this.user = new User();
			this.loadFont();
			this.loadFxml();
			this.loadParser();
			this.addTextFieldListener();
			this.initializeShortCuts();
			this.updateStartPage();
			UtilityMethod.makeDraggable(stage, dragNode);

			if (!Constant.ERROR_PRINT_ON) {
				silentErrorStream();
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

/**
 * ========================================================================
 * Methods which might be called during initialization (in constructor)
 * ========================================================================
 */
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java
	 */

	/**
	 * Load the FXML file to render the graphical user interface
	 * @throws IOException
	 */
	private void loadFxml() throws IOException {
		FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(
				Constant.RESOURCE_FXML));
		fxmlLoader.setRoot(this);
		fxmlLoader.setController(this);
		fxmlLoader.load();
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java
	 */

	/**
	 * Retrieve the user input from the input box (hooked with 'input')
	 * 
	 * @param willClear		willClear whether the input area will be cleared
	 * @return				the user input as a string
	 */
	public String getUserInput(boolean willClear) {
		String text = input.getText();
		if (willClear) {
			input.clear();
		}
		return text;
	}
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java
	 */

	/**
	 * Update the display area to the string specified
	 * 
	 * @param textToDisplay	textToDisplay string of the text to be displayed
	 */
	public void setDisplayText(String textToDisplay) {
		VBox displayContent = new VBox();
		Label textLabel = new Label(textToDisplay);
		displayContent.getChildren().clear();
		displayContent.getChildren().add(textLabel);

		displayScrollPane.setContent(displayContent);
		setDisplayScrollbarStyle();
		displayScrollPane.setFocusTraversable(true);
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java
	 */

	/**
	 * Update the display area to display the given task list
	 * 
	 * @param taskList	task list to be displayed
	 */
	public void setDisplayPane(ArrayList<Task> taskList) {
		setDisplayScrollbarStyle();
		if (taskList == null || taskList.isEmpty()) {
			// task list is empty, nothing to display
			this.loadPreview();
		} else {
			VBox displayContentBox = new VBox();
			displayContentBox.setStyle(Constant.CSS_STYLE_DISPLAY_CONTENT_BOX);
			displayContentBox.setAlignment(Pos.CENTER);
			GridPane taskPane = LayoutManager.getTaskPane(taskList, getWidth());
			displayContentBox.getChildren().add(taskPane);
			displayScrollPane.setContent(displayContentBox);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java
	 */

	/**
	 * Update the input area to given text
	 * 
	 * @param text	text String of text to be displayed
	 */
	private void updateTextField(final String text) {
		final MainViewController instance = this;
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				if (text == null) {
					//clear the input
					instance.input.deleteText(0, instance.input.getText()
							.length());
					;
				}
				instance.input.setText(text);
				instance.input.positionCaret(text.length());
				instance.input.selectAll();
			}
		});
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java
	 */

	/**
	 * Catch the event when user press the enter key
	 */
	@FXML
	private void onEnter() {
		String command = getUserInput(true);
		if (command.equals("")) {
			performDisplay();
		} else {
			this.commandHistory.add(command);
			this.currentCommandIndex = this.commandHistory.size();
			this.execute(command);
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java
	 */

	private ArrayList<Task> displayTrashedList() {
		ArrayList<Task> queryResult;
		try {
			queryResult = this.user.getTrashedTaskList();
			if (queryResult.isEmpty()) {
				setDisplayText(Constant.PROMPT_MESSAGE_DISPLAY_EMPTY_TASK);
				// TODO: create a box for empty list
				return null;
			} else {
				return queryResult;
			}
		} catch (Exception e) {
			e.printStackTrace();
			setConsoleText(Constant.PROMPT_MESSAGE_DISPLAY_ERROR);
			return null;
		}
	}

	private ArrayList<Task> displayFinishedList() {
		ArrayList<Task> queryResult;
		try {
			queryResult = this.user.getFinishedTaskList();
			if (queryResult.isEmpty()) {
				setDisplayText(Constant.PROMPT_MESSAGE_DISPLAY_EMPTY_TASK);
				// TODO: create a box for empty list
				return null;
			} else {
				return queryResult;
			}
		} catch (Exception e) {
			e.printStackTrace();
			setConsoleText(Constant.PROMPT_MESSAGE_DISPLAY_ERROR);
			return null;
		}
	}

	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java
	 */

	/**
	 * 
	 * @param userInput
	 * @return
	 */
	private String untag(String userInput) {
		boolean isAllSucceeded = true;
		String returnValue = "";
		try {
			ArrayList<String> tags = parser.pickUntag(userInput);
			int index = parser.pickIndex(userInput).get(0);
			for (String tag : tags) {
				try {
					boolean isThisSucceeded = this.user.untag(index - 1, tag);
					if (!isThisSucceeded) {
						returnValue += (Constant.PROMPT_MESSAGE_UNTAG_TASK_FAILED + ": " + index);
					}
					isAllSucceeded &= isThisSucceeded;
				} catch (CommandFailedException cfe) {
					return cfe.toString();
				}
			}
		} catch (CommandFailedException e) {
			return e.toString();
		}

		return isAllSucceeded ? Constant.PROMPT_MESSAGE_UNTAG_TASK_SUCCESSFULLY
				: returnValue;
	}


/**
 * ==========================================================================
 * the delegation methods to respond to shortcuts
 * ==========================================================================
 */
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java





	/**
	 * origin: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java
	 */

	@Override
	public void onHotKey(HotKey key) {
		String tag = "";
		int cursorPosition = this.input.getCaretPosition();
		switch (key.keyStroke.getKeyCode() + key.keyStroke.getModifiers()) {
		case KeyEvent.VK_D + Constant.MODIFIER_ALT:
			descriptionTag = toggleTag(descriptionTag);
			tag = descriptionTag;
			insertTextIntoTextField(cursorPosition, tag);
			break;

		case KeyEvent.VK_A + Constant.MODIFIER_ALT:
			dateTag = toggleTag(dateTag);
			tag = dateTag;
			insertTextIntoTextField(cursorPosition, tag);
			break;

		case KeyEvent.VK_C + Constant.MODIFIER_ALT:
			commandTag = toggleTag(commandTag);
			tag = commandTag;
			insertTextIntoTextField(cursorPosition, tag);
			break;

		case KeyEvent.VK_T + Constant.MODIFIER_ALT:
			tagTag = toggleTag(tagTag);
			tag = tagTag;
			insertTextIntoTextField(cursorPosition, tag);
			break;

		case KeyEvent.VK_I + Constant.MODIFIER_ALT:
			indexTag = toggleTag(indexTag);
			tag = indexTag;
			insertTextIntoTextField(cursorPosition, tag);
			break;

		case KeyEvent.VK_P + Constant.MODIFIER_ALT:
			priorityTag = toggleTag(priorityTag);
			tag = priorityTag;
			insertTextIntoTextField(cursorPosition, tag);
			break;

		case KeyEvent.VK_ENTER + Constant.MODIFIER_CTRL:
			this.loadPreview();
			break;

		case KeyEvent.VK_C + Constant.MODIFIER_CTRL:
			insertTextIntoTextField(cursorPosition, Constant.TEXT_INSERTED_ADD);
			break;

		case KeyEvent.VK_R + Constant.MODIFIER_CTRL:
			insertTextIntoTextField(cursorPosition, Constant.TEXT_INSERTED_DISPLAY);
			break;

		case KeyEvent.VK_U + Constant.MODIFIER_CTRL:
			insertTextIntoTextField(cursorPosition, Constant.TEXT_INSERTED_UPDATE);
			break;

		case KeyEvent.VK_D + Constant.MODIFIER_CTRL:
			insertTextIntoTextField(cursorPosition, Constant.TEXT_INSERTED_DELETE);
			break;

		case KeyEvent.VK_F + Constant.MODIFIER_CTRL:
			insertTextIntoTextField(cursorPosition, Constant.TEXT_INSERTED_SEARCH);
			break;

		case KeyEvent.VK_M + Constant.MODIFIER_CTRL:
			insertTextIntoTextField(cursorPosition, Constant.TEXT_INSERTED_RELOAD_MODEL);
			break;

		case KeyEvent.VK_BACK_SPACE + Constant.MODIFIER_CTRL:
			String inputString = (String) input.getCharacters();
			insertTextIntoTextField(cursorPosition,
					inputString.substring(0, inputString.lastIndexOf(Constant.SPLITOR_SPACE)));
			break;

		case KeyEvent.VK_1 + Constant.MODIFIER_CTRL:
			changeToOngoingList();
			break;

		case KeyEvent.VK_2 + Constant.MODIFIER_CTRL:
			changeToFinishedList();
			break;
			
		case KeyEvent.VK_3 + Constant.MODIFIER_CTRL:
			changeToTrashedList();
			break;

		case KeyEvent.VK_4 + Constant.MODIFIER_CTRL:
			changeToHelp();
			break;
		}

		switch (key.keyStroke.getKeyCode()) {
		case KeyEvent.VK_UP:
			this.currentCommandIndex--;
			try {
				updateTextField(this.commandHistory
						.get(this.currentCommandIndex));
			} catch (ArrayIndexOutOfBoundsException e) {
				// TODO log
				this.currentCommandIndex++;
			}
			break;

		case KeyEvent.VK_DOWN:
			try {
				this.currentCommandIndex++;
				updateTextField(this.commandHistory
						.get(this.currentCommandIndex));
			} catch (ArrayIndexOutOfBoundsException e) {
				// TODO log
				this.currentCommandIndex--;
			}
			break;
		}

	}


/**
 * ==========================================================================
 * methods that related to view changing, the names explain their uses
 * ==========================================================================
 */	
	
	// End of segment: C:\Users\Gabriella\My Documents\NUS\2103\main\src\userInterface\MainViewController.java





